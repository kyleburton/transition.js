---
layout: default2
title: API Documentation
navigation: documentation
---

h1. Defining a Test Suite

After creating the symbolic link to the Transition.js @public@ directory, your next step is to define your test suite.  You do this in the file @test-suite.js@ in the same place you created the symbolic link:

{% highlight bash %}
public/
  +-- transition -> ~/projects/transition.js/public
  +-- test-suite.js
  +-- tests
      +-- add-a-list.js
      +-- add-todo-item.js
      +-- index-page.js
      +-- mark-item-as-done.js
{% endhighlight %}

Tests can be defined within the @test-suite.js@ file directly, or in separate files.  A common pattern is to place utility code for testing your application in the test-suite.js with tests each in separate files:

{% highlight javascript %}
(function () {
  var root        = this,
      TodoTestLib = {};

  this.TodoTestLib = TodoTestLib;

  TodoTestLib.deleteTestList = function () {
    ...
  };

  TodoTestLib.createTestList = function () {
    ...
  };

}.call(this));

Transition.loadScript('/tests/index-page.js');
Transition.loadScript('/tests/add-a-list.js');
Transition.loadScript('/tests/add-todo-item.js');
Transition.loadScript('/tests/mark-item-as-done.js');
{% endhighlight %}

h1. Optinally Defining a @test-suite.html@ for Static Content

If your tests themselves require helper libraries or other static content (like their own UI controls, html, etc.), you can create a @test-suite.html@ file next to @test-suite.js@.  The content of this file will be fetched and appended to the @<body>@ *before* the @test-suite.js@ file itself is loaded.

h1. Defining a Test

Tests are added to the suite by calling the @Transition.addTest@ DSL function, passing an object defining the test's properties.

The test must have 2 properties:

* @name@: the name of the test
* @states@: the set of states that comprise the test.

Other properties inthe test definition will be ignored by the framework, though they will still be available to your test.  You can use additional properties to define helper functions or other settings for your specific tests.

h3. Adding States

States can be constructed using @Transition.newState@.  Each state must have:

* a name
* an @on-enter@ callback, which is called once, when the state is entered.
* a set of exit transitions, created with the @to@ DSL function.

Here is an example that loads the root page of the example TODO application and asserts that the form for creating lists is present:

{% highlight javascript %}
(function () {

  this.addTest({
    name: 'Test Index Page',

    states: [
      this.newState('init', this.navigateTo_('about:blank'))
        .to('mainPage', this.constantly_(true)),

      this.newState('mainPage', this.navigateTo_('/'))
        .to('success', this.elementExists_('form[action="/lists"]'))
    ]
  });

}.call(Transition));
{% endhighlight %}

h3. Transitions and Predicates

Transition predicates can be specified as any of the following:

* a function that returns a boolean
* the name of a property of your test, as a string, referencing a function that returns a boolean

If the name is passed as a string, it may optionally be prefixed with an exclamation point to indicate it should be logically negated.  This is provided as a convienience so that you don't have to write both the positive and negative forms of a predicate.

The above can be written to use a property name for the @mainPageLoaded@ as follows:

{% highlight javascript %}
(function () {

  this.addTest({
    name: 'Test Index Page',

    states: [
      this.newState('init', this.navigateTo_('about:blank'))
        .to('mainPage', this.constantly_(true)),

      this.newState('mainPage', this.navigateTo_('/'))
        .to('success', 'mainPageLoaded')
    ],

    mainPageLoaded: function () {
      return this.elementExists_('form[action="/lists"]');
    }
  });

}.call(Transition));
{% endhighlight %}

h1. Transition's Apis

h2. DOM Helpers

The DOM helpers make working with the main frame (where the application runs) simpler.  They will use jQuery within the web application if it is present (by detecting the presence of @$@), or wrap the main frame's document in a jQuery object.

When a function is suffixed with an underscore, it creates a closure over the arguments and returns a function that performs the action.  This is useful for when callbacks are required in your tests, avoiding having to write out an anonymous function.

h3. @Transition.navigateTo@, @Transition.navigateTo_@

These set the main frame's location.

h3. @Transition.find@

This executes jQuery's find, returning the result set.

h3. @Transition.elementExists@, @Transition.elementExists_@

These boolean predicates test if an element exists in the page.

h3. @Transition.elementNotExists@, @Transition.elementNotExists_@

These boolean predicates test if an element does not exist in the page.

h2. Logging

There are 6 logging levels, each indicating a different severity:

* @Transition.Log.trace@
* @Transition.Log.debug@
* @Transition.Log.info@
* @Transition.Log.warn@
* @Transition.Log.error@
* @Transition.Log.fatal@

The Log output window's filter setting will determine what is visible based on the level.

The log functions use "@sprintf@":https://github.com/kvz/phpjs/blob/master/functions/strings/sprintf.js for formatting entries.  The first argument will be treated as the format string and additional arguments will supply values for the format string.

The format strings follow the "sprintf":https://github.com/kvz/phpjs/blob/master/functions/strings/sprintf.js library with a single addition: @%a@ for formatting JavaScript objects:

{% highlight javascript %}
  Transition.Log.info("Object is: %a", {an: 'object', num: 123});
  // => [23:20:30] Object is: {"an":"object","num":123}
{% endhighlight %}

